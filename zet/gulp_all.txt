Розглянемо, що таке Gulp і як за допомогою нього можна автоматизувати роботу Front-end


1. Основні ресурси.

	Node.js: https://nodejs.org/en/

	Gulp: http://gulpjs.com/

	Bower: http://bower.io/

	Browsersync: https://browsersync.io/


2. Огляд.

	Gulp - це інструмент, що допомагає автоматизувати рутинні завдання веб-розробки

	Gulp призначений для вирішення таких завдань, як:

		створення веб-сервера і автоматичне перезавантаження сторінки в браузері при збереженні коду, слідкування за змінами в файлах проекта;

		використання різноманітних JS, CSS и HTML препроцесорів (CoffeeScript, Less, Sass, Stylus, Jade тощо);

		мініфікація CSS і JS коду, а також оптимізація і конкатенація окремих файлів проекту в один;

		автоматичне створення вендорних префіксів (приставок до назви CSS властивостей, що додають виробники браузерів для нестандартних властивостей) для CSS;

		управління файлами і папками в рамках проекта - створення, видалення, зміна імені;

		запуск і контроль виконання зовнішніх команд операційної системи;

		робота з зображеннями - стиснення, створення спрайтів, ресайз (png, jpg, svg тощо);

		деплой (відправка на зовнішній сервер) проекту по FTP, SFTP, Git тощо;

		підключення і використання в проекті необмежено великої кількості Node.js і Gulp утиліт, програм і плагінів;

		створення різноманітних карт проекта і автоматизація іншої ручної праці

	Будь-який проект, що використовує Gulp, має в корені файл gulpfile.js, який містить набір інструкцій по управлінню проектом

	Будемо працювати в папці BA - JS_Gulp

	Написання інструкцій для Gulp не є програмуванням, хоча вони і пишуться на мові JS
	Не слід лякатись великих gulpfile.js, майже всі інструкції однотипні і мають загальні риси


3. Встановлення Gulp.

	Для роботи Gulp має бути встановлено Node.js
	(При встановленні Node.js галочками мають бути відмічені встановлення npm і додавання програми в Path)

	Відкриваємо командний рядок і виконуємо наступну команду:

		npm install -g gulp

		З даної команди видно, що запускається менеджер пакетів npm (Node Package Manager), який командою install встановлює Gulp в систему
		Ключ -g говорить про те, що пакет встановиться в систему глобально, тобто саме в систему, а не в папку проекту
		Без ключа -g пакет встановлюється в ту папку, у якій виконуються поточні команди, тому треба бути уважними
		Встановлення з ключом -g не має значення, з якого місця відбувається


4. Створення проекту Gulp.

	Якщо натиснути "Shift" і праву кнопку мишки на папці з проектом, то можна відкрити командний рядок з "вже прописаним шляхом" проекту (і додатково не переходити) - "Відкрити вікно команд"

	У "шляху" не має бути папок, що прописані кириличними символами, тому що багато пакетів таких шляхів не розуміє

	Далі виконуємо ініціалізацію проекта в тій папці, яку створили

		npm init

	Відповідаємо на декілька питань, по інструкції, заповнюємо метаінформацію про проект, краще все на англійській мові

		1. Називаємо проект "name": "js_gulp"

		2. Лишаємо поточну версію "version": "1.0.0"

		3. Вводимо короткий опис проекту "description": "My First Gulp Project"

		4. entry point, test command, git repository, keywords залишаємо по замовчуванню

		5. "author": AnisimoffAO

		6. license залишаємо по замовчуванню і вводимо yes

		У результаті такого нескладного першого налаштування нового Gulp-проекту в папці з'явиться новий файл package.json

	Файл package.json є файлом маніфеста проекту, що описує окрім тієї інформації, що вноситься в терміналі, ще й інформацію про пакети, які використані у проекті

	Наприклад, якщо встановити пакет в проект Gulp з ключем --save-dev, то пакет і версія, що використовується, автоматично додадуться в package.json

	Такий облік дозволить швидко розгортати новий проект з використанням вже готового package.json і встановлювати необхідні модулі з залежностями, які прописані в package.json в нових проектах

	Встановлюємо в проект Gulp

		npm install gulp --save-dev

		У даному рядку: npm встановлює пакет gulp в поточну папку (тому що нема ключа -g, який встановлює пакет глобально в систему) і зберігає назву пакета з версіює в файл package.json

			"devDependencies": {
				"gulp": "^3.9.1"
			}

	Крім того, з'являється папка node_modules, яка тепер має у своєму складі встановлений пакет gulp і необхідні залежності

	В дану папку автоматично будуть попадати всі модулі і залежності, які будемо встановлювати у проект

	Папок з залежностями може бути дуже багато, незважаючи на те, що встановлюється не так багато пакетів

	Це пов'язано з тим, що у додадок до основних пакетів встановлюються програми, які необхідні для коректної роботи основного пакету

	Нічого чистити і видаляти з папки node_modules не потрібно


5. Загальноприйнята структура каталогів в проектах.

	У багатьох проектах є загальна структура каталогів, наприклад, більшість проектів мають папку dist i app

	Створюємо початкову структуру проекту згідно всіх правил гарного тону веб-розробки
	(всі файли, яких не було, поки що створюємо порожніми)

		gulp_project/
			app/
				css/
				fonts/
				img/
				js/
				less/
				index.html
			dist/
			node_modules/
			gulpfile.js
			package.json

		Дана структура зустрічається досить часто, практично у всіх проектах, але це не аксіома і деякі проекти можуть мати взагалі іншу структуру

		Папка app/ буде містити всі вихідні матеріали проекту - оригінальні CSS, Less, js файли бібліотек, оригінальні зображення
		Це папка вихідних кодів нашого проекту

		Папка dist/ буде містити вже готовий продукт післі зборки, оптимізований, стиснутий, тощо
		Це папка продакшена


6. gulpfile.js.

	Створюється в корені проекту

	Відкриваємо в редакторі і пишемо

		var gulp = require('gulp');

		Даним рядком ми підключаємо Gulp до проекту, за допомогою функції require
		Дана функція підключає пакети з папки node_modules у проект, записуючи їх у змінну
		У даному випадку створюється змінна gulp

	Далі ми вже можемо працювати з цією змінною і створювати таски (інструкції)

		gulp.task('mytask', function() {
			console.log('Привіт, я таск!');
		});

		mytask - це назва команди, що буде викликати в потрібному місці gulpfile.js

	Окрім того, можна у командному рядку виконати таск напряму, прописавши

		gulp mytask

	Це, звичайно, дуже простий базовий приклад створення таска

	Як правило, таски складніші і мають у своєму складі деякі додаткові команди

		gulp.task('mytask', function () {
			return gulp.src('source-files')		// Вибірка вихідних файлів для обробки плагіном
				.pipe(plugin())					// Виклик Gulp плагіна для обробки файла
				.pipe(gulp.dest('folder'))		// Вивід результуючого файла в папку призначення (dest - пункт призначення)
		})

	Це база Gulp, тепер можна створювати інструкції

	Для початку створимо обробник, який буде компілювати Less файли в CSS (CSS препроцесінг)


7. Gulp Less.

	Встановлюємо пакет gulp-less в проект з збереженням версії і назви в package.json

		npm install gulp-less --save-dev

	Далі підключимо gulp-less в файлі gulpfile.js

	Зверніть увагу, що змінні для підключення пакетів можна перерахувати через кому

		var gulp = require('gulp'),
			less = require('gulp-less'); // Підключаемо Less пакет, що було встановлено

	Створюємо у папці app/less файл main.less, задамо у ньому фон body - чорний

		body {
			background: #000;
		}

	Пишемо для нього обробник в gulpfile.js - таск less

		gulp.task('less', function () {
			return gulp.src('app/less/main.less')
				.pipe(less())
				.pipe(gulp.dest('app/css'))
		})

	Після цього, логічним буде виконати в терміналі

		gulp less

		У результаті виконання команди в папці app/css з'явится файл main.css


8. Вибірка файлів для gulp.src.

	В принципі, вже розглянуто все, що необхідно знати про Gulp, тепер будемо поглиблюватись у кожну деталь того, що було наведено вище

	Вибірка файлів у прикладі вище доволі проста, ми брали файл напряму

		gulp.src('app/less/main.less')

	Але файли також можна вибирати за шаблоном

	Найбільш розповсюджені шаблони вибірки:

		*.less - вибирає всі файли незалежно від імені, що мають певне розширення (у даному випадку, .less) у директорії less;

		**/*.less, **/*.js - вибирає всі файли з розширенням .less, .js у всіх вкладених директоріях незалежно від структури;

		!header.less - виключення файлу з загальної вибірки - gulp.src('!app/less/main.less');

		Ще можна прописувати масивом -

			gulp.src(['!app/less/main.less', 'app/less/**/*.less'])

			Таким записом буде вибрано всі файли .less, окрім файлу main.less

		*.+(scss|sass) - задає комплексний шаблон для декількох типів файлів, які розділені вертикальною смугою, у вибірку попадуть будь-які sass і scss файли з відповідної директорії або піддиректорій


	Внесемо деякі зміни в таск less та зробимо його більш універсальним

		gulp.task('less', function(){
			return gulp.src('app/less/**/*.less')	// Беремо всі less файли з папки less і дочірніх, якщо такі будуть
				.pipe(less())
				.pipe(gulp.dest('app/css'))
		});

		Брати напряму один окремий файл не завжди зручно, тому що у папці less можуть з'явитись і інші файли з розширенням less, що можуть бути використані у проекті


9. Нагляд за змінами в файлах (Gulp Watch).

	Gulp підтримує метод watch для перевірки файлів, що зберігаються після внесення змін, і має наступний синтаксис

		gulp.watch('watch-files', ['task1', 'task2']);

	Якщо, наприклад, потрібно наглядати за всіма змінами у файлах less проекту, можна використати наступну конструкцію

		gulp.watch('app/less/**/*.less', ['less']);

		Gulp наглядає за всіма less файлами і при збереженні виконує таск less, що автоматично компілює їх в css файли

	Створення окремого таску для нагляду за всіма необхідними файлами

		gulp.task('watch', function() {
			gulp.watch('app/less/**/*.less', ['less']); // Нагляд за less файлами, де через кому вказується масив тасків, що будуть виконуватись
			// Нагляд за іншими типами файлів
		});

	Якщо запустити в консолі gulp watch, Gulp буде автоматично слідкувати за всіма змінами в файлах less при збереженні і компілювати їх в css

		Для перевірки цього процесу відкриваємо main.less і вносимо зміни

			body {
				background-color: green;
			}

			При цьому відбудеться корегування файлу main.сss, що автоматично підтверджується у командному рядку відпрацюванням відповідного таску


10. Додавання базової розмітки в index.html для подальшої роботи.

	<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta charset="UTF-8">
			<title>Document</title>
			<link rel="stylesheet" href="css/main.css">
		</head>
		
		<body>
			Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quasi suscipit magni fugiat in sint magnam iusto veritatis! Incidunt, ducimus, veritatis. Laboriosam amet, ipsa ipsum quisquam, possimus eveniet assumenda! Aliquid, molestias!
		</body>
	</html>

	Де тільки підключимо скомпільовані стилі <link rel="stylesheet" href="css/main.css"> і тестовий контент

	Далі було б непогано зробити автоматичне оновлення css на сторінці при збереженні, тобто потрібно використати інструмент, що запустить та побудує сервер і забезпечить слідкування за файлами і автоматичне оновлення (LiveReload)


11. Встановлення автоматичного оновлення сторінок з використанням Browser Sync.

	Browser Sync - це відмінне рішення для LiveReload сторінок при збереженні файлів

	При чому релоад відбувається не тільки в одному браузері, але і у всіх браузерах мережі, будь то мобільні пристрої або інші комп'ютери в одній Wi-Fi мережі

		https://www.browsersync.io/

	Встановлюємо Browser Sync у проект

		npm install browser-sync --save-dev

	Підключимо у файл gulpfile.js, як робили раніше з пакетом gulp-less

		browserSync = require('browser-sync'); // Підключаємо Browser Sync

	Створюємо таск для Browser Sync

		gulp.task('browser-sync', function() {	// Створюємо таск browser-sync
			browserSync({						// Виконуємо browser Sync
				server: {						// Визначаємо параметри сервера
					baseDir: 'app'				// Директорія для сервера - app
				},
				notify: false					// Відключаємо повідомлення зовнішнього ресурсу
			});
		});

	І виконаємо його
		
		gulp browser-sync

	Сервер для роботи і автоматичного релоада готовий!


12. Відслідковування змін в Less.

	Якщо файл Less оновлюється, автоматично інжектимо в HTML змінений CSS файл (підставляємо CSS в DOM)

	Для цього модифікуємо таск less

		gulp.task('less', function() {						// Створюємо таск "less"
			return gulp.src('app/less/**/*.less')			// Беремо всі less файли з папки less і дочірніх, якщо є
				.pipe(less())								// Перетворюємо Less в CSS за допомогою gulp-less
				.pipe(gulp.dest('app/css'))					// Вивантажуємо результат в папку app/css
				.pipe(browserSync.reload({stream: true}))	// Оновлюємо CSS на сторінці при зміні
		});

	Все, що залишилось зробити - це запустити таск browser-sync перед тим, як запуститься gulp watch

	Для цього модифікуємо таск watch, додавши виконання browser-sync і less до запуску watch

	При цьому browser-sync і less виконується до того, як виконається watch, що дозволяє налаштувати правильну послідовність виконання процесів

		gulp.task('watch', ['browser-sync', 'less'], function() {
			gulp.watch('app/less/**/*.less', ['less']); // Нагляд за less файлами
			// Нагляд за іншими типами файлів
		});

	Розташуємо таск watch після всіх інших тасків і у результаті отримаємо такий gulpfile.js

		var gulp = require('gulp'),
			less = require('gulp-less'), // Підключаемо Less пакет, що було встановлено
			browserSync = require('browser-sync'); // Підключаємо Browser Sync

		gulp.task('less', function() {						// Створюємо таск "less"
			return gulp.src('app/less/**/*.less')			// Беремо всі less файли з папки less і дочірніх, якщо є
				.pipe(less())								// Перетворюємо Less в CSS за допомогою gulp-less
				.pipe(gulp.dest('app/css'))					// Вивантажуємо результат в папку app/css
				.pipe(browserSync.reload({stream: true}))	// Оновлюємо CSS на сторінці при зміні
		});

		gulp.task('browser-sync', function() {	// Створюємо таск browser-sync
			browserSync({						// Виконуємо browser Sync
				server: {						// Визначаємо параметри сервера
					baseDir: 'app'				// Директорія для сервера - app
				},
				notify: false					// Відключаємо повідомлення зовнішнього ресурсу
			});
		});

		gulp.task('watch', ['browser-sync', 'less'], function() {
			gulp.watch('app/less/**/*.less', ['less']); // Нагляд за less файлами
			// Нагляд за іншими типами файлів
		});

	Можна запускати, запускаємо саме таск watch, що включає browser-sync і less

		gulp watch

		Відбувається наступне

			browser-sync включається (Starting)
			browser-sync запустився (Finished)

			less включається (Starting)
			якщо були якісь зміни - застосовується
			less запустився (Finished)

			watch включається (Starting)
			watch запустився (Finished)

			browser-sync [BS] видає URL-и:

				Local: локальний
				External: екстернал - можна ввести цю адресу у Wi-Fi мережі на мобільному пристрої і там автоматично буде відбуватись reload

				UI: користувацький інтерфейс локального browser-sync, що дозволяє робити деякі налаштування, проте, як правило, застосовуються налаштування по замовчуванню

	Змінюємо дані в main.less

		body {
			background-color: grey;
		}

		При збереженні змін дані у браузері автоматично оновляться без примусового перезавантаження сторінки і працює це достатньо швидко

		У командному рядку спрацьовує

			less включається (Starting)
			застосовується до файлу main.css
			less запустився (Finished)


13. Оновлення сторінки при збереженні HTML і JS.

	В папці js створюємо кастомний файл common.js, де будуть розташовані користувацькі функції, і дадаємо всередину

		$(function() {

		});

	Крім того, потрібно оновлювати при збереженні index.html

	Тому внесемо зміни до таску watch

		gulp.task('watch', ['browser-sync', 'less'], function() {
			gulp.watch('app/less/**/*.less', ['less']);			// Нагляд за less файлами у папці less
			gulp.watch('app/*.html', browserSync.reload);		// Нагляд за HTML файлами у корені проекта
			gulp.watch('app/js/**/*.js', browserSync.reload);	// Нагляд за JS файлами у папці js
		});

		Тут використовується функція browserSync.reload, яку надає пакет Browser Sync

	Після змін у файлі gulpfile.js обов'язково потрібно перезапускати сервер

		gulp watch

	Якщо тепер внести будь-які зміни до файлу index.html

		<body>
			test
		</body>

		Відбудеться автоматичне перезавантаження сторінки

		У командному рядку спрацьовує

			Reloading Browsers

	Аналогічний процес буде відбуватись для common.js


14. Оптимізація JS та бібліотек.

	Частіше за все, оптимізації потребують бібліотеки та сторонні jQuery і JS плагіни

	common.js з користувацькими функціями часто не такий великий і його навіть лишають відкритим та не оптимізованим

	Створюємо у папці app папку libs, що буде містити необхідні сторонні бібліотеки та плагіни

	Всі бібліотеки будемо розміщувати в окремих папках


	14.1. Для встановлення нових бібліотек будемо використовувати Bower.

			https://bower.io/

		Встановлюємо Bower

			npm install -g bower

			Зверніть увагу, що для роботи Bower необхідний Git!

		Додамо налаштування Bower у проекті, для чого у папці проекту створимо файл .bowerrc, у який напишемо

			{
				"directory" : "app/libs/"
			}

			Даним налаштуванням вказується шлях по замовчуванню для встановлення плагінів за допомогою Bower

		Суто для прикладу встановимо jQuery і Magnific Popup

			bower install jquery magnific-popup

			Де не вказується ніяких --save-dev, тому що це бібліотеки для Front-End-у

		Після чого за шляхом app/libs/ буде дві папки jquery і magnific-popup

		Зверніть увагу, що всі (або майже всі) плагіни мають папку dist
		В цій папці розташовуються готові файли продакшена, які будуть використані у проекті


	14.2. Створюємо таск scripts, що буде збирати всі JS файли бібліотек в один і мініфікувати їх.

		Для цього встановимо 2 пакета:

			gulp-concat - для конкатенації

			gulp-uglifyjs - для стиснення JS-файлів

			npm install gulp-concat gulp-uglifyjs --save-dev

			Які, відповідно, пропишуться в package.json

		Підключимо нові бібліотеки у gulpfile.js

			var gulp = require('gulp'),					// Підключаемо Gulp
				less = require('gulp-less'),			// Підключаемо Less пакет
				browserSync = require('browser-sync'),	// Підключаємо Browser Sync
				concat = require('gulp-concat'),		// Підключаємо gulp-concat (для конкатенації файлів)
				uglify = require('gulp-uglifyjs');		// Підключаємо gulp-uglifyjs (для стиснення JS)

		Створюємо таск для збірки та стиснення всіх бібліотек (після less)

			gulp.task('scripts', function() {
				return gulp.src([													// Беремо всі необхідні бібліотеки у вигляді масиву
						'app/libs/jquery/dist/jquery.min.js',						// Беремо jQuery
						'app/libs/magnific-popup/dist/jquery.magnific-popup.min.js'	// Беремо Magnific Popup
					])
					.pipe(concat('libs.min.js'))									// Збираємо їх до купи у новому файлі libs.min.js
					.pipe(uglify())													// Стискаємо JS файл
					.pipe(gulp.dest('app/js'));										// Вивантажуємо в папку app/js
			});

		Перевіряємо, як працює новий таск scripts

			gulp scripts

			Після виконання якого у папці js з'явився файл libs.min.js

		Тепер у файлі index.html у самому низу підключимо скріпти

			<script src="js/libs.min.js"></script>
			<script src="js/common.js"></script>

		Перевіряємо за допомогою запуску команди

			gulp watch

			І вносимо зміни до файлу common.js

				$(function() {

					// $('body').fadeOut();

				});

				Відповідно, тепер відбувається оновлення у зміні в скріптах

		Виконання таска scripts можна запустити перед виконанням watch

			gulp.task('watch', ['browser-sync', 'less', 'scripts']

			Після цього автоматично буде відбуватись збірки та стиснення

		Далі можна підключити до проекту всі необхідні CSS файли бібліотек
		У нашому випадку, тільки одна бібліотека потребує підключення - це Magnific Popup

		Створюємо новий файл libs.less, куди будуть імпортуватись всі наявні бібліотеки

		Зробимо це через @import

			@import (less) "app/libs/magnific-popup/dist/magnific-popup.css"; // Імпортуємо бібліотеку Magnific Popup

		На виході, в папці app/css отримуємо додатково до main.css файл libs.css, що містить стилі всіх бібліотек, якщо виконаємо таск

			gulp less

		Файл main.css нема особливого змісту мініфікувати, тому що він містить кастомні (користувацькі) стилі

		А файл libs.css мініфікуємо

		Для мініфікації CSS встановимо пакети gulp-cssnano і gulp-rename

			npm install gulp-cssnano gulp-rename --save-dev

		Підключимо їх у gulpfile.js

			var gulp = require('gulp'),					// Підключаемо Gulp
				less = require('gulp-less'),			// Підключаемо Less пакет
				browserSync = require('browser-sync'),	// Підключаємо Browser Sync
				concat = require('gulp-concat'),		// Підключаємо gulp-concat (для конкатенації файлів)
				uglify = require('gulp-uglifyjs'),		// Підключаємо gulp-uglifyjs (для стиснення JS)
				cssnano = require('gulp-cssnano'),		// Підключаємо пакет для мініфікації CSS
				rename = require('gulp-rename');		// Підключаємо бібліотеку для зміни імен файлів

		Створимо відповідний таск після таску scripts

			gulp.task('css-libs', ['less'], function() {
				return gulp.src('app/css/libs.css')		// Вибираємо файл для мініфікації
					.pipe(cssnano())					// Стискаємо
					.pipe(rename({suffix: '.min'}))		// Додаємо суфікс .min
					.pipe(gulp.dest('app/css'));		// Вивантажуємо в папку app/css
			});

			Таск less краще викликати до запуску css-libs, щоб було що мініфікувати

		Зразу додамо даний таск в watch для того, щоб бібліотеки зібрались у процесі запуску проекту, де замість less пропишемо css-libs (таск less вже використано в css-libs)

			gulp.task('watch', ['browser-sync', 'css-libs', 'scripts'] ...

		Перевіряємо

			gulp watch

		Вносимо невеличкі корективи в index.html

			<link rel="stylesheet" href="css/libs.min.css">
			<link rel="stylesheet" href="css/main.css">


15. Підготовка до продакшена.

	Для тестового варіанту завантажимо декілька зображень до папки img

	Для продакшена (збірки в папку dist - туди не будемо закидати бібліотеки, тільки все оптимізоване та стиснене) створимо окремий таск build в кінці gulpfile.js

	У даній інструкції зробимо збірку Less, JS і вивантаження того, що є, в папку dist

		gulp.task('build', ['less', 'scripts'], function() {

			var buildCss = gulp.src([					// Переносимо CSS стилі в продакшен
				'app/css/main.css',
				'app/css/libs.min.css'
				])
			.pipe(gulp.dest('dist/css'))

			var buildFonts = gulp.src('app/fonts/**/*')	// Переносимо шрифти в продакшен
			.pipe(gulp.dest('dist/fonts'))

			var buildJs = gulp.src('app/js/**/*')		// Переносимо скріпти в продакшен
			.pipe(gulp.dest('dist/js'))

			var buildHtml = gulp.src('app/*.html')		// Переносимо HTML в продакшен
			.pipe(gulp.dest('dist'));

		});

		Таким способом можна виконувати мультитаски


16. Очистка папки dist.

	Перед тим, як збирати проект, потрібно очистити папку dist, щоб не лишалось зайвих залишків від попередніх ітерацій з проектом

	Встановимо і підключимо пакет del

		npm install del --save-dev

		del = require('del'); // Підключаемо бібліотеку для видалення файлів і папок

	Створюємо таск очистки clean и додаємо його виконання перед виконанням build (до watch)

		gulp.task('clean', function() {
			return del.sync('dist');					// Видаляємо папку dist перед збіркою
		});

	Перевіряємо його роботу

		gulp clean

		Після чого папка dist повністю видалена з усім вмістом

	Дещо модифікуємо таск build, у зв'язку з тим, що таск clean потрібно викликати перед виконанням збірки

		gulp.task('build', ['clean', 'less', 'scripts'] ...

	Тепер перевіряємо

		gulp build


17. Автоматична оптимізація зображень.

	У папці app/img є 3 зображення, що необхідно перенести в папку продакшена, оптимізуючи при цьому

	Для оптимізації зображень встановимо 2 пакети (gulp-imagemin, imagemin-pngquant) і підключимо їх після успішного встановлення

		npm install gulp-imagemin imagemin-pngquant --save-dev

		imagemin = require('gulp-imagemin'), // Підключаемо бібліотеку для роботи з зображеннями
		pngquant = require('imagemin-pngquant'); // Підключаемо бібліотеку для роботи з png

	Створимо таск img для стиснення зображень на продакшен та викличемо його після очищення (до watch)

		gulp.task('img', function() {
			return gulp.src('app/img/**/*')	// Беремо всі зображения з app
				.pipe(imagemin({			// Стискаємо їх з найкращими налаштуваннями
					interlaced: true,
					progressive: true,
					svgoPlugins: [{removeViewBox: false}],
					use: [pngquant()]
				}))
				.pipe(gulp.dest('dist/img')); // Вивантажуємо на продакшен
		});

	І додатково пропишемо його в таск build, щоб у процесі білдінгу відбувалась обробка зображень

		gulp.task('build', ['clean', 'img', 'less', 'scripts'] ...

	Тепер перевіряємо

		gulp build

	Все нормально до тих пір, поки кількість зображень в проекті не перевищує 3 шт (не так багато)
	Велика кількість картинок буде оброблятись значно довше, тому до обробки зображень було б непогано додати кеш, щоб картинки кешувались і економили час на збірці проекту

	Для цього встановимо і підключимо gulp-cache

		npm install gulp-cache --save-dev

		cache = require('gulp-cache'); // Підключаємо бібліотеку кешування

	Модифікуємо таск img

		gulp.task('img', function() {
			return gulp.src('app/img/**/*') // Беремо всі зображения з app
				.pipe(cache(imagemin({		// Стискаємо їх з найкращими налаштуваннями з врахуванням кешування
					interlaced: true,
					progressive: true,
					svgoPlugins: [{removeViewBox: false}],
					use: [pngquant()]
				})))
				.pipe(gulp.dest('dist/img')); // Вивантажуємо на продакшен
		});

	При білдінгу, якщо буде перенесено папку з зображеннями, мініфікація зображень працювати не буде із-за кешу

	Тому потрібно зробити таск для очистки кешу після clean

		gulp.task('clear', function() {
			return cache.clearAll(); // Будемо прописувати виключно вручну при необхідності очистки кешу
		});


18. Автоматичне створення префіксів CSS за допомогою Gulp.

	Вендорні префікси необхідні для забезпечення максимальної сумісності з усіма сучасними браузерами

	Було б логічно зробити автоматичне додавання префіксів, щоб написавши в Less

		display: flex;

	Отримати на виході

		display: -webkit-box;
		display: -webkit-flex;
		display: -ms-flexbox;
		display: flex;

	Встановимо пакет gulp-autoprefixer і підключимо його в gulpfile.js

		npm install gulp-autoprefixer --save-dev

		autoprefixer = require('gulp-autoprefixer'); // Підключаємо бібліотеку для автоматичного додавання префіксів

	Модифікуємо саме таск less, тому що в "лібсах" розробники вже про це попіклувались

		gulp.task('less', function() {						// Створюємо таск "less"
			return gulp.src('app/less/**/*.less')			// Беремо всі less файли з папки less і дочірніх, якщо є
				.pipe(less())								// Перетворюємо Less в CSS за допомогою gulp-less
				.pipe(autoprefixer(['last 15 versions', '> 1%', 'ie 8', 'ie 7'], { cascade: true })) // Створюємо префікси
				.pipe(gulp.dest('app/css'))					// Вивантажуємо результат в папку app/css
				.pipe(browserSync.reload({stream: true}))	// Оновлюємо CSS на сторінці при зміні
		});

	Перевіряємо

		gulp watch

	Тепер в main.less пропишемо

		body {
			background-color: grey;
			display: flex;
		}

		Властивості display: flex; обов'язково потрібні вендорні префікси

	Після зберігання у файлі main.сss отримаємо

		body {
			background-color: grey;
			display: -webkit-box;
			display: -webkit-flex;
			display: -ms-flexbox;
			display: flex;
		}


19. Автоматична генерація спрайтів за допомогою Gulp.

	Встановимо і підключимо пакет spritesmith

		npm install gulp.spritesmith --save-dev

		spritesmith = require('gulp.spritesmith'); // Підключаемо бібліотеку для генерації спрайтів

	Створимо таск sprite для генерації спрайтів перед таском img

		gulp.task('sprite', function () {
			var spriteData = gulp.src('app/img/sprite/*.png').pipe(spritesmith({
				imgName: 'sprite.png',
				cssName: 'sprite.css'
			}));
			return spriteData.pipe(gulp.dest('app/img/sprite'));
		});

	І додамо в таск watch

		gulp.task('watch', ['browser-sync', 'css-libs', 'scripts', 'sprite'] ...


20. Дефолтний таск Gulp.

	Отже, маємо 2 головних таска

		gulp watch - для роботи над проектом у режимі "онлайн"

		gulp build - для збірки проекта на продакшен без зайвих файлів, папок і з стиснутими картинками

	Оскільки частіше за все буде потрібен таск watch, можна повішати його на дефолтний таск, щоб не писати в консолі постійно gulp watch, а писати просто gulp

		gulp.task('default', ['watch']);